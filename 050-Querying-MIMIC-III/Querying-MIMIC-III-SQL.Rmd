---
title: "Querying MIMIC-III -- SQL"
output:
  html_document:
    toc: yes
  html_notebook:
    toc: yes
---

efg | 2018-09-24 | Updated 2018-12-16.

# Introduction

The purpose of this RStudio notebook is to reproduce the initial SQL examples in [Querying MIMIC-III](https://mimic.physionet.org/tutorials/intro-to-mimic-iii/), Section 3 "Patient numbers" through Section 7 "Services."  Unfortuantely, the online source shows SQL code but does not show the "correct" answers, so a definitive conclusion that this all matches is not possible.

The examples from the Tutorial Problem in Section 8 are in a separate notebook.

**An equivalent dplyr example notebook shows roughly the same steps using dplyr/dbplyr for data manipulation in the Tidyverse instead of SQL**. This enables a direct comparison between solving the problem using SQL and dplyr/dbplyr.

Many of the comments below are from the source above.

SQL statements were lightly edited for readability in the SQL program "chunks". 

# Overview

This tutorial provides an introduction to the structure and content of the MIMIC-III database. By the end of this tutorial you will be able to:

* Obtain metadata from the various database objects (tables, views, etc);

* Perform basic queries on a single table

* Perform basic ‘joins’ to combine tables and extract useful information

* Use database ‘views’ to extract high-level information.

# Database schema

An interactive website, generated by SchemaSpy, gives an [overview of the schema](https://mit-lcp.github.io/mimic-schema-spy/). 

Database metadata can be viewed on the [columns tab](https://mit-lcp.github.io/mimic-schema-spy/columns.byTable.html).

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(cli.unicode = FALSE)
time.1 <- Sys.time()
```

```{r, comment=NA}
library(DBI)
library(RPostgres)
library(dbplyr, warn.conflicts = FALSE)
```

```{r, comment=NA}
MimicDB <- dbConnect(RPostgres::Postgres(), 
                     host     = "localhost",
                     dbname   = "mimic",
                     user     = Sys.getenv("MIMIC_User"),
                     password = Sys.getenv("MIMIC_Password"),
                     bigint   = "numeric",   # See RBloggers 2018-03-16 posting
                     options  = "-c search_path=mimiciii")
```

# Querying MIMIC-III

## 3. Patient numbers

```{sql, connection=MimicDB}
SELECT * 
FROM   PATIENTS
LIMIT  5
```

Obtain the number of patients with the following query:

```{sql, connection=MimicDB}      
SELECT COUNT(*)
FROM   patients
```

The ‘gender’ column identifies the gender of the patient. We can obtain the distinct values used to indicate gender using the following query:

```{sql, connection=MimicDB}
SELECT DISTINCT(gender)
FROM   patients
```

We can see that ’M’ and ‘F’ are the two characters used to indicate patient gender. We can use this information to obtain the number of female patients by adding a condition to select rows where the gender is ‘F’:

```{sql, connection=MimicDB}
SELECT COUNT(*)
FROM   patients
WHERE  gender = 'F'
```

And the numbers of male and female patients can be obtained using the following query:

```{sql, connection=MimicDB}
SELECT   gender, COUNT(*)
FROM     patients
GROUP BY gender
```

## 4. Mortalilty and admissions

A flag which records whether or not a patient died in the hospital is stored in the patients table. Count the number of patients who died using the following query:

```{sql, connection=MimicDB}
SELECT   expire_flag, COUNT(*)
FROM     patients
GROUP BY expire_flag
```

The database also contains date of death for patients who died inside the hospital in the column ‘dod_hosp’ and the date of death found in social security death records in ‘dod_ssn’. This information from both columns is merged in the ‘dod’ column with priority given to ‘dod_hosp’. Note that this database contains adult and neonatal patients which will affect the mortality statistics. Categorizing patients into different age groups is carried out in the next section.

## 5. Patient age and mortality

To determine the adult mortality rate we must first select the adult patients. We define adults as those patients who are 15 years old or above at the date of their first admission. To perform this query, we must combine the patients and admissions tables to find patient admission dates and dates of birth. We have denoted `admissions` with the alias `a` and `patients` with alias `p`:

```{sql, connection=MimicDB}
SELECT 
  p.subject_id, 
  p.dob, 
  a.hadm_id,
  a.admittime, 
  p.expire_flag
  
FROM 
  admissions a
  
  INNER JOIN patients p
  ON p.subject_id = a.subject_id
  
LIMIT 5
```

Next we find the earliest admission date for each patient. This requires the use of two functions: the `MIN` function, which obtains the minimum value, and the `PARTITION BY` function, which determines the groups over which the minimum value is obtained. To determine the earliest admission time for each patient:

```{sql, connection=MimicDB}
SELECT 
  p.subject_id, 
  p.dob, 
  a.hadm_id,
  a.admittime, 
  p.expire_flag,
  MIN (a.admittime) OVER (PARTITION BY p.subject_id) AS first_admittime

FROM 
  admissions a
  
  INNER JOIN patients p
  ON p.subject_id = a.subject_id
  
ORDER BY a.hadm_id, p.subject_id
  
LIMIT 5
```

A patient’s age is given by the difference between their date of birth and the date of their first admission. We can obtain this by combining the above query with another query to provide the ages. Furthermore, we assign categories to different ages: >= 15 years old are adults and the rest are assigned to other categories. Note the use of the WITH clause, which allows us to make a temporary view which we can query against in subsequent lines.

```{sql, connection=MimicDB}
WITH first_admission_time AS
(
  SELECT
    p.subject_id, 
    p.dob, 
    p.gender,
    MIN (a.admittime) AS first_admittime,
    MIN( ROUND( (cast(admittime as date) - cast(dob as date)) / 365.242,2) ) AS first_admit_age
    
  FROM 
    patients p
  
    INNER JOIN admissions a
    ON p.subject_id = a.subject_id
    
  GROUP BY p.subject_id, p.dob, p.gender
  ORDER BY p.subject_id
)

SELECT
  subject_id, 
  dob, 
  gender,
  first_admittime, 
  first_admit_age,
    
  CASE
    -- all ages > 89 in the database were replaced with 300
    WHEN first_admit_age > 89
    then '>89'
      
    WHEN first_admit_age >= 14
    THEN 'adult'
      
    WHEN first_admit_age <= 1
    THEN 'neonate'
    ELSE 'middle'
    END AS age_group
    
FROM first_admission_time
  
ORDER BY subject_id

LIMIT 5
```

The above query can now be combined with the `WHERE` and `COUNT` functions described earlier to determine the number of adult patients, whether or not they died, and therefore, their mortality rate.

```{sql, connection=MimicDB}
WITH first_admission_time AS
(
  SELECT
    p.subject_id, 
    p.dob, 
    p.gender,
    MIN (a.admittime) AS first_admittime,
    MIN( ROUND( (cast(admittime as date) - cast(dob as date)) / 365.242,2) ) AS first_admit_age
    
  FROM 
    patients p
    
    INNER JOIN admissions a
    ON p.subject_id = a.subject_id
    
  GROUP BY p.subject_id, p.dob, p.gender
  ORDER BY p.subject_id
), 

age as
(
  SELECT
    subject_id, 
    dob, 
    gender,
    first_admittime, 
    first_admit_age,
    
    CASE
      -- all ages > 89 in the database were replaced with 300
      -- we check using > 100 as a conservative threshold to ensure we capture all these patients
      WHEN first_admit_age > 100
      then '>89'
      
      WHEN first_admit_age >= 14
      THEN 'adult'
      
      WHEN first_admit_age <= 1
      THEN 'neonate'
      ELSE 'middle'
    END AS age_group
  
  FROM first_admission_time
)

select 
  age_group, 
  gender,
  count(subject_id) as NumberOfPatients
  
from age

group by age_group, gender

order by age_group, gender
```

Note that no ‘middle’ patients show up -- this reflects the fact that MIMIC-III does not contain data from paediatric patients.

[Note:  The constant 365.242 days/year above is curious.  The years 1900 and 2100 are not leap years, but 2000 was.  The constant 365.25 works fine for years between 1901 and 2099.]

## 6. ICU stays

In the MIMIC-III database, we define an ICU stay to be continuous if a patient is returned to an ICU room within 24 hours of being moved to a ward. Patient ICU movements are recorded in the `transfers` table:

```{sql, connection=MimicDB}
SELECT *
FROM   transfers
LIMIT  5
```

The columns should be fairly self explanatory.  

The `prev_careunit` and `curr_careunit` contain the names of the previous and current careunit respectively. The `transfers` table also includes `prev_wardid` and `curr_wardid` columns, which contain the IDs of the previous and current careunit respectively. Ward IDs, which specify the room within a ward, have no corresponding key in order to protect patient health information.

The `transfers` table may have multiple entries per patient to provide detail of all movement between various careunits of the hospital. The first entry in the `transfers` table for a patient who comes into the ICU will have nothing in the `prev_careunit` column. Similarly, the last entry for a patient will have nothing in the `curr_careunit`. Entries that have nothing in both previous and current careunit columns indicate that the patient has been transfered between non intensive care units. An example query for one patient and result from the transfers table is shown below. 

## 7. Services

`Services` is a newly added table in MIMIC-III which contains information about the transfers from being under one service to another during a patient’s stay. The `services table` contains columns including `prev_service` and `curr_service` which contain the names of previous and current services respectively. `transfertime` is the time at which the patient was moved from `prev_service` to `curr_service`.

```{sql, connection=MimicDB}
SELECT *
FROM   services
WHERE  HADM_ID = 112213
```

# Close database

```{r, comment=NA}
dbDisconnect(MimicDB)
```

```{r, comment=NA, echo=FALSE}
time.2 <- Sys.time()
processingTime <- paste("Processing time:", 
                        sprintf("%.1f",
                                as.numeric(difftime(time.2, time.1,
                                                    units="secs"))), "secs\n")
```

`r processingTime`
`r format(time.2, "%Y-%m-%d %H%M")`
