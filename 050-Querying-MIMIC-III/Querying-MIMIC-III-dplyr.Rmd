---
title: "Querying MIMIC-III -- dplyr"
output:
  html_document:
    toc: yes
  html_notebook:
    toc: yes
---

efg | 2018-10-08 | Updated 2018-12-23.

# Introduction   

The purpose of this RStudio notebook is to reproduce the initial database query examples in  [Querying MIMIC-III](https://mimic.physionet.org/tutorials/intro-to-mimic-iii/),  Section 3 “Patient numbers” through Section 7 “Services”, using RStudio's dplyr/dbplyr. 

The examples from the Tutorial Problem are in a separate notebook.

**An equivalent SQL example notebook shows roughly the same steps using SQL for data manipulation.**. This enables a direct comparison between solving the problem using dplyr/dbplyr and SQL.

Many of the comments below are from the source above.

# Overview   

This tutorial provides an introduction to the structure and content of the MIMIC-III database. By the end of this tutorial you will be able to:

* Obtain metadata from the various database objects (tables, views, etc);

* Perform basic queries on a single table

* Perform basic ‘joins’ to combine tables and extract useful information

* Use database ‘views’ to extract high-level information.

# Database schema

An interactive website, generated by SchemaSpy, gives an [overview of the schema](https://mit-lcp.github.io/mimic-schema-spy/). 

Database metadata can be viewed on the [columns tab](https://mit-lcp.github.io/mimic-schema-spy/columns.byTable.html).

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(cli.unicode = FALSE)
time.1 <- Sys.time()
options(width=100)
```

Helper function:  Common formatting mostly for data.frames/tibbles below

```{r}
Show <- function(data)
{
  data            %>%
  kable("html")   %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "condensed"),
                position = "left", full_width = FALSE, font_size=12)
}
```     

Packages

```{r, comment=NA}
library(DBI)
library(RPostgreSQL)
library(tidyverse)
library(dbplyr, warn.conflicts=FALSE)
library(kableExtra)
library(lubridate, warn.conflicts=FALSE)   # date computations
```

Open Database

```{r}
MimicDB <- dbConnect(RPostgreSQL::PostgreSQL(), 
                     dbname   = "mimic",
                     user     = Sys.getenv("MIMIC_User"),
                     password = Sys.getenv("MIMIC_Password"),
                     options  = "-c search_path=mimiciii")
```

Table references

```{r}
admissions <- tbl(MimicDB, in_schema("mimiciii", "admissions"))
patients   <- tbl(MimicDB, in_schema("mimiciii", "patients"))
transfers  <- tbl(MimicDB, in_schema("mimiciii", "transfers"))
services   <- tbl(MimicDB, in_schema("mimiciii", "services"))
```

# Querying MIMIC-III  

## 3. Patient numbers

```{r, comment=NA}
patients   %>% 
  head(5)  %>%
  Show()
```

When reading the statement above, read the "%>%" pipe operator as "then". 

Obtain the number of patients with the following query:   

```{r, comment=NA}
patients  %>% 
  count() %>%
  Show()
```

The `gender` column identifies the gender of the patient. We can obtain the distinct values used to indicate gender using the following query:      

```{r, comment=NA}
patients          %>% 
  select(gender)  %>% 
  distinct()      %>%
  collect()       %>%
  Show()
```

`collect` forces evaluation on the database server with the results passed in-memory to R.  

We can see that 'M' and 'F' are the two characters used to indicate patient gender. We can use this information to obtain the number of female patients by adding a condition to select rows where the gender is 'F':

```{r, comment=NA}
patients                %>% 
  filter(gender == "F") %>% 
  count()               %>%
  Show()
```

And the numbers of male and female patients can be obtained using the following query:  

```{r, comment=NA}
patients           %>% 
  group_by(gender) %>% 
  count()          %>%
  Show()
```

## 4. Mortalilty and admissions

A flag which records whether or not a patient died in the hospital is stored in the patients table. Count the number of patients who died using the following query:

```{r, comment=NA}
patients %>% 
  select(expire_flag)   %>% 
  group_by(expire_flag) %>% 
  count()               %>%
  Show()
```

The database also contains date of death for patients who died inside the hospital in the column ‘dod_hosp’ and the date of death found in social security death records in ‘dod_ssn’. This information from both columns is merged in the ‘dod’ column with priority given to ‘dod_hosp’. Note that this database contains adult and neonatal patients which will affect the mortality statistics. Categorizing patients into different age groups is carried out in the next section.

## 5. Patient age and mortality

To determine the adult mortality rate we must first select the adult patients. We define adults as those patients who are 15 years old or above at the date of their first admission. To perform this query, we must combine the patients and admissions tables to find patient admission dates and dates of birth. We have denoted `admissions` with the alias `a` and `patients` with alias `p`:

```{r, comment=NA}
admissions                                                 %>% 
  inner_join(patients, by="subject_id")                    %>%
  select(subject_id, dob, hadm_id, admittime, expire_flag) %>%
  head(5)                                                  %>%
  Show()
```

Next we find the earliest admission date for each patient. This requires the use of two functions: the `MIN` function, which obtains the minimum value, and the `PARTITION BY` function, which determines the groups over which the minimum value is obtained. To determine the earliest admission time for each patient:

dplyr conversion notes for SQL PARTITION BY:

* [dplyr version of SQL `PARTITION BY` with sort order for use with SQL backend](https://community.rstudio.com/t/dplyr-version-of-sql-partition-by-with-sort-order-for-use-with-sql-backend/7822)

* [SQL type window functions in R (preferably dplyr)](https://stackoverflow.com/questions/49343333/sql-type-window-functions-in-r-preferably-dplyr)

```{r, comment=NA}
admissions                                                   %>% 
  inner_join(patients, by="subject_id")                      %>%
  select(subject_id, dob, hadm_id, admittime, expire_flag)   %>%
  group_by(subject_id, dob, hadm_id, admittime, expire_flag) %>%
  summarize(first_admittime = min(admittime, na.rm = TRUE))  %>%
  arrange(hadm_id, subject_id)                               %>%
  head(5)                                                    %>%
  Show()
```

A patient’s age is given by the difference between their date of birth and the date of their first admission. We can obtain this by combining the above query with another query to provide the ages. Furthermore, we assign categories to different ages: >= 15 years old are adults and the rest are assigned to other categories. Note the use of the WITH clause, which allows us to make a temporary view which we can query against in subsequent lines.

```{r, comment=NA}
patients                                                        %>% 
  inner_join(admissions, by="subject_id")                       %>%
  select(subject_id, dob, gender, admittime)                    %>%
  group_by(subject_id, dob, gender, admittime)                  %>%
    mutate(admit_age = ((DATE(admittime) - 
                         DATE(dob)) / 365.242) %>% round(2))    %>%
    summarize(first_admittime = min(admittime, na.rm=TRUE),
              first_admit_age = min(admit_age, na.rm=TRUE))     %>%
    select(-admittime)                                          %>%
  ungroup()                                                     %>%
  mutate(age_group = case_when(first_admit_age  >  89  ~  ">89",
                               first_admit_age  >= 14  ~  "adult",
                               first_admit_age  <=  1  ~  "neonate",
                               TRUE                    ~  "middle"))  %>%
  arrange(subject_id)                                                 %>%
  head(5)                                                             %>%
  Show()
```

The above query can now be combined with the `WHERE` and `COUNT` functions described earlier to determine the number of adult patients, whether or not they died, and therefore, their mortality rate.

```{r, comment=NA}
patients                                                        %>% 
  inner_join(admissions, by="subject_id")                       %>%
  select(subject_id, dob, gender, admittime)                    %>%
  group_by(subject_id, dob, gender, admittime)                  %>%
    mutate(admit_age = ((DATE(admittime) - 
                         DATE(dob)) / 365.242) %>% round(2))    %>%
    summarize(first_admittime = min(admittime, na.rm=TRUE),
              first_admit_age = min(admit_age, na.rm=TRUE))     %>%
    select(-admittime)                                          %>%
  ungroup()                                                     %>%
  mutate(age_group = 
           case_when(first_admit_age  >  89  ~  ">89",
                     first_admit_age  >= 14  ~  "adult",
                     first_admit_age  <=  1  ~  "neonate",
                     TRUE                    ~  "middle"))      %>%
  select(age_group, gender, subject_id)                         %>%
  group_by(age_group, gender)                                   %>%
    summarize(NumberOfPatients = n_distinct(subject_id))        %>%
  ungroup()                                                     %>%
  arrange(age_group, gender)                                    %>%
  collect()                                                     %>%
  Show()
```

Note that no ‘middle’ patients show up -- this reflects the fact that MIMIC-III does not contain data from paediatric patients.

## 6. ICU stays

In the MIMIC-III database, we define an ICU stay to be continuous if a patient is returned to an ICU room within 24 hours of being moved to a ward. Patient ICU movements are recorded in the `transfers` table:

```{r, comment=NA}
transfers  %>%
  head(5)  %>%
  Show()
```


The columns should be fairly self explanatory.  

The `prev_careunit` and `curr_careunit` contain the names of the previous and current careunit respectively. The `transfers` table also includes `prev_wardid` and `curr_wardid` columns, which contain the IDs of the previous and current careunit respectively. Ward IDs, which specify the room within a ward, have no corresponding key in order to protect patient health information.

The `transfers` table may have multiple entries per patient to provide detail of all movement between various careunits of the hospital. The first entry in the `transfers` table for a patient who comes into the ICU will have nothing in the `prev_careunit` column. Similarly, the last entry for a patient will have nothing in the `curr_careunit`. Entries that have nothing in both previous and current careunit columns indicate that the patient has been transfered between non intensive care units. An example query for one patient and result from the transfers table is shown below. 

```{r, comment=NA}
transfers                    %>%
  filter(hadm_id == 112213)  %>%
  Show()
```

## 7. Services

`Services` is a newly added table in MIMIC-III which contains information about the transfers from being under one service to another during a patient’s stay. The `services table` contains columns including `prev_service` and `curr_service` which contain the names of previous and current services respectively. `transfertime` is the time at which the patient was moved from `prev_service` to `curr_service`.

```{r, comment=NA}
services                     %>%
  filter(hadm_id == 112213)  %>%
  Show()
```

# Close database

```{r, comment=NA}
dbDisconnect(MimicDB)
```

```{r, comment=NA, echo=FALSE}
time.2 <- Sys.time()
processingTime <- paste("Processing time:", 
                        sprintf("%.1f",
                                as.numeric(difftime(time.2, time.1,
                                                    units="secs"))), "secs\n")
```

`r processingTime`
`r format(time.2, "%Y-%m-%d %H%M")`
